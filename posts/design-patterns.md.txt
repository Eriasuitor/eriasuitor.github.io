1:HL["/_next/static/media/2aaf0723e720e8b9-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/2ceb952b30e2a1aa.css",{"as":"style"}]
0:["LDYVSgUoWMCGLWdEnEnAt",[[["",{"children":["posts",{"children":[["titles","design-patterns.md","c"],{"children":["__PAGE__?{\"titles\":[\"design-patterns.md\"]}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/2ceb952b30e2a1aa.css","precedence":"next"}]],["$L4",["$","meta",null,{"name":"next-size-adjust"}]]]]]]
5:HL["/_next/static/css/aecf48c3599473b1.css",{"as":"style"}]
6:I{"id":"781","chunks":["477:static/chunks/477-842f1f04f188eba1.js","293:static/chunks/293-2da7c5eb70318a7f.js","185:static/chunks/app/layout-0dca780ab9f2f97f.js"],"name":"ProgressBar","async":false}
7:I{"id":"7477","chunks":["180:static/chunks/0e02fca3-f15a9edc93bc40dc.js","477:static/chunks/477-842f1f04f188eba1.js","162:static/chunks/app/posts/[...titles]/page-b4cbe76b4517af3a.js"],"name":"","async":false}
8:I{"id":"5962","chunks":["477:static/chunks/477-842f1f04f188eba1.js","293:static/chunks/293-2da7c5eb70318a7f.js","185:static/chunks/app/layout-0dca780ab9f2f97f.js"],"name":"","async":false}
9:I{"id":"3211","chunks":["272:static/chunks/webpack-5e124f8f8a7edcef.js","253:static/chunks/bce60fc1-c1e3a00a8422f9c3.js","769:static/chunks/769-a3d1ede45644f606.js"],"name":"","async":false}
a:I{"id":"5767","chunks":["272:static/chunks/webpack-5e124f8f8a7edcef.js","253:static/chunks/bce60fc1-c1e3a00a8422f9c3.js","769:static/chunks/769-a3d1ede45644f606.js"],"name":"","async":false}
3:[["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__className_0ec1f4","children":[["$","$L6",null,{}],["$","header",null,{"className":"layout_header__F4njZ undefined","children":["$","nav",null,{"className":"layout_nav__KLFKz","children":[["$","div",null,{"className":"$undefined","children":["$","$L7",null,{"href":"/","children":"首页"}]}],["$","div",null,{"className":"$undefined","children":[["$","$L7","https://github.com/eriasuitor",{"target":"_blank","href":"https://github.com/eriasuitor","title":"Eriasuitor","children":["$","$L8",null,{"src":"/github.png","width":18,"height":18,"alt":"media icon","className":"layout_media_icon__h3csI"}]}]]}]]}]}],["$","$L9",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$La",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L9",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$La",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L9",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["titles","design-patterns.md","c"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":["$","div",null,{"children":"Loading"}],"loadingStyles":[],"hasLoading":true,"template":["$","$La",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$Lb",null],"segment":"__PAGE__?{\"titles\":[\"design-patterns.md\"]}"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/aecf48c3599473b1.css","precedence":"next"}]]}],"segment":["titles","design-patterns.md","c"]},"styles":[]}],"segment":"posts"},"styles":[]}]]}]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"any"}]]
c:I{"id":"8365","chunks":["180:static/chunks/0e02fca3-f15a9edc93bc40dc.js","477:static/chunks/477-842f1f04f188eba1.js","162:static/chunks/app/posts/[...titles]/page-b4cbe76b4517af3a.js"],"name":"Toc","async":false}
b:[null,["$","$Lc",null,{"postContentKey":"post_content","className":"post_toc__vi2PO"}],["$","div",null,{"className":"post_section__Yw0mz","children":["$","div",null,{"className":"$undefined","children":[["$","div",null,{"className":"section_sectionTitle__AXzn3","children":["$","$L7",null,{"href":"design-patterns.md","children":"设计模式"}]}],["$","div",null,{"className":"section_sections__AtWe3","children":[]}]]}]}],["$","div",null,{"id":"post_content","dangerouslySetInnerHTML":{"__html":"\n<blockquote>\n  <p>著作说明：文中图片均有“稀土掘金技术社区”水印，因为本人于该网站首次发布此文，原始链接为：<a href=\"https://juejin.cn/post/7065511789031030820\">https://juejin.cn/post/7065511789031030820</a>。</p>\n</blockquote>\n<blockquote>\n  <p>此文档处于 beta 阶段，非正式发布版本。</p>\n</blockquote>\n<blockquote>\n  <p>本文示例采用 Java 语言实现，请注意其他语言在部分特性上可能存在的差异。</p>\n</blockquote>\n<h1>设计模式七大原则</h1>\n<p>这里所说的原则，仅仅是一些软件工程的概念，并非准则。这些原则均由不同的人在其书籍或文章中提出，并不一定具有整体性、系统性，需结合实际情况选择性的使用。在常见的设计模式中，会有很多违反这些原则的情况。</p>\n<h2>1. 单一职责原则(Single Responsibility Principle, SRP)</h2>\n<p>每个类都应该只有单一的功能，也即唯一的改变原因。更为通俗的说，我们需要对业务功能做合理的划分。比如在 UserService 中我们提供了注册和登录功能，但其中涉及的操作 DB、验证码发送等细节操作的方法我们都需要放在专门的服务中并暴露给 UserService 调用。</p>\n<p>职责的划分往往“不是一门技术，而是一门艺术”，是系统解耦的关键所在。</p>\n<h2>2. 接口隔离原则(Interface Segregation Principle, ISP)</h2>\n<p>此原则强调细化接口以获得使用上的灵活性，拒绝将多种功能方法整合到一个臃肿的接口中。类实现接口时，该接口应未提供任何冗余的方法，如果有则说明该接口应该被拆分为多个接口。</p>\n<h2>3. 开闭原则(Open Closed Principle, OCP)</h2>\n<p>在为一个良好设计的系统新增功能时，我们应该做到对拓展开放，对修改关闭。我们可以通过“抽象约束、封装变化”来实现这一目标。具体来说，我们可以通过抽象类或接口来定义抽象层，并将稳定不变的逻辑在抽象层固定，而可变部分则在派生类中实现。当新增需求时，我们可以直接派生一个新的实现类而无需修改既有代码。</p>\n<h2>4. 里氏替换原则(Liskov Substitution Principle, LSP)</h2>\n<p>\n  将基类都替换成它的子类时，要求程序的行为没有变化。具体来说，子类可以拓展父类的功能而不能改变父类原有的功能，也即子类可以新增自己的方法，但不要重写父类的方法。此原则阐述了有关继承的一些原则，也就是什么时候适合使用继承，是对开闭原则的补充。\n  具体实践为：\n</p>\n<ol>\n  <li>子类可以实现父类的抽象方法，但不能覆写父类的非抽象方法。</li>\n  <li>子类可以增加自己特有的方法。</li>\n  <li>子类重载父类方法时，方法的传入参数不能比父类严格。如父类传入 List，子类则不能传入 ArrayList（ArrayList 实现了 List 接口）。</li>\n  <li>子类实现父类方法时，返回类型不能比父类宽松。如父类返回 ArrayList，子类则不能返回 List。</li>\n</ol>\n<p>违反此原则的典型例子是：正方形(Square)继承长方形(Rectangle)。</p>\n<p>因为正方形势必会重载长方形的 setLength 和 setWidth 方法（无论是设置长还是宽，都需要同时修改长和宽以满足二者相等的要求），造成<strong><em>将长方形（基类）都替换成正方形（子类），程序的行为发生了变化</em></strong>。</p>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-comment\">// 替换前</span>\n<span class=\"hljs-type\">Rectangle</span> <span class=\"hljs-variable\">shape</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Rectangle</span>();\nshape.setLength(<span class=\"hljs-number\">100</span>);\nshape.setWidth(<span class=\"hljs-number\">50</span>);\nSystem.out.printf(shape.area());   <span class=\"hljs-comment\">// 5000</span>\n<span class=\"hljs-comment\">// 替换后</span>\n<span class=\"hljs-type\">Square</span> <span class=\"hljs-variable\">shape</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Square</span>();\nshape.setLength(<span class=\"hljs-number\">100</span>);\nshape.setWidth(<span class=\"hljs-number\">50</span>); <span class=\"hljs-comment\">// 势必会同时设置widht与length</span>\nSystem.out.printf(shape.area());   <span class=\"hljs-comment\">// 2500</span>\n</code></pre>\n<p>此时可以依据合成复用原则，在 Square 中添加一个类型为 Rectangle 的成员变量并取消二者的继承关系，同时核心功能依然通过调用 Rectangle 的方法实现，但不再提供 setWidth 方法，在 setLength 时，同时调用 Rectangle 的 setWidth 和 setLength 方法。</p>\n<h2>5. 依赖倒转(倒置)原则(Dependence Inversion Principle, DIP)</h2>\n<p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p>\n<p>也即我们应该面向接口或抽象编程，不要面向具体实现。如在 UserService 中，我们需要发送短信验证码，但短信服务商有多个，我们在 UserService 中引入的应该是“SmsInterface”或“SmsAbstractService”而非\"AliSmsService\"，而引入的具体实现类则由外部决定并传入。</p>\n<p>具体实践为：</p>\n<ol>\n  <li>每个类应尽量实现了接口或继承了抽象类。</li>\n  <li>引用对象时应尽量引用其接口或基类。</li>\n  <li>任何类都不应该从具体类派生。</li>\n  <li>使用继承时尽量遵循里氏替换原则。</li>\n</ol>\n<h2>6. 迪米特法则(Law of Demeter, LoD)</h2>\n<p>组合（合成）关系：是一种<strong><em>强的拥有</em></strong>关系，如树根与大树的关系，树根与其他部分组成了大树，并且大树一定有树根。</p>\n<p>聚合关系：是一种<strong><em>弱的拥有</em></strong>关系，如大树与花园的关系，大树可以与其他花花草草组成花园，但花园并不是一定要有大树。</p>\n<p>又称最少知识原则（Least Knowledge Principle, LKP)，简单的说，就是仅调用与当前对象有<strong>关联</strong>、聚合或组合关系的对象中的方法。而对于其他对象，可通过第三方转发调用。</p>\n<h2>7. 合成复用原则(Composite Reuse Principle, CRP)</h2>\n<p>又称组合/聚合复用原则(Composition/Aggregate Reuse Principle, CARP)，</p>\n<p>此原则强调尽量使用合成（组合）或聚合来达到复用的目的。满足里氏替换原则时可使用继承，其他情况则选择合成或聚合。</p>\n<p>通过继承实现复用时，父类的内部细节通常对于子类来说是可见的，故又称为“白盒复用”。通过合成或聚合实现复用时，无法看到目标类的内部细节，故又称为“黑盒复用”。</p>\n<blockquote>\n  <p>“审慎地组合使用对象组合与类继承，优于单独使用其中任何一种。”</p>\n  <p>摘录来自: 马丁·福勒(Martin Fowler). “重构：改善既有代码的设计（第 2 版）</p>\n</blockquote>\n<h1>说明</h1>\n<h2>UML 类图样例</h2>\n<p>\n  <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5865365e395f45ddb547e6a803a0a5b5~tplv-k3u1fbpfcp-watermark.image?\" alt=\"5-200Z1142Qb13-2.jpg\">\n</p>\n<h1>创建型模式(Creational Patterns)</h1>\n<h2>简单工厂模式(Simple factory)</h2>\n<h3>场景描述</h3>\n<p>我们需要根据用户选择的运输方式，如\"road\"、\"sea\"、\"air\"，实例化 Ship, Plane, Truck 三种交通工具的一种并返回。</p>\n<h3>思路</h3>\n<ol>\n  <li>我们可以将这个函数放在任意服务类中，但这类函数往往被多处调用，所以考虑写在工具类。故实现如下：</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Utils</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Transport <span class=\"hljs-title function_\">createTransport</span><span class=\"hljs-params\">(String transport)</span> {\n        <span class=\"hljs-keyword\">switch</span> (transport) {\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"road\"</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Truck</span>();\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"seas\"</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Ship</span>();\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"air\"</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Plane</span>();\n            <span class=\"hljs-keyword\">default</span>:\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Exception</span>(<span class=\"hljs-string\">\"Unknown transport\"</span>);\n        }\n    }\n}\n</code></pre>\n<h3>模式</h3>\n<p>这个工具类你可以称为工厂类，也就是专门用来生产实例的工厂，同时为了让大家知道这个类是工厂类，将 Utils 类名改为 TransportFactory。</p>\n<h3>变体</h3>\n<p>有时候我们会像这样创建对象：</p>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Factory</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Transport <span class=\"hljs-title function_\">createTruck</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">YellowTruck</span>();\n    }\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Transport <span class=\"hljs-title function_\">createShip</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Ship</span>()\n    }\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Transport <span class=\"hljs-title function_\">createPlane</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Plane</span>()\n    }\n}\n</code></pre>\n<p>这也是<strong><em>简单工厂模式</em></strong>，它似乎毫无意义，但从代码结构上看，却有如下好处：</p>\n<ol>\n  <li>我们可以根据情况返回其他的 Truck 类或代理类，比如 YellowTruck、ProxyTruck，或者传入参数来决定具体的实现类。</li>\n  <li>函数名往往隐含着业务注解，我们可以通过修改工厂类获取实例的方法名来使业务逻辑更清晰。</li>\n  <li>我们可以返回一个新实例化的对象，也可以返回一个缓存的对象以实现对象的共用。</li>\n</ol>\n<h2>抽象工厂模式(Abstract Factory)</h2>\n<h3>场景描述</h3>\n<p>\n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eac47bbb5b374279b76a35db65d6f9d3~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  现有如上图所示的继承关系，我们需要根据 global.context.os 获取当前平台，并在所有使用 Button 和 Dialog 的地方实例化对应平台的组件类，同时我们希望当需要适配新平台时能足够方便。\n</p>\n<h3>思路</h3>\n<ol>\n  <li>我们的获取逻辑拥有可复用性，所以使用一个类 Components 并为其提供 getButton、getDialog 函数，在需要实例化组件类的地方，调用对应方法即可。</li>\n  <li>getButton、getDialog 函数需要根据不同平台返回不同的具体对象，一般来说可以写很多的 if...else...语句进行判断并返回正确的对象。</li>\n  <li>\n    然而每个函数中都写同一段 if...else...显然是不明智的，基于面向对象的思想，我们可以使用继承，故使用如下继承体系。\n    \n    <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a0ed87268b4b7cb85d93be5ef09ae3~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n  <li>最后我们只需要维护一个 AbstractComponents 类型的 components，并在系统初始化时通过读取 global.context.os 的值根据此值具体决定实例化 IOSComponents, AndroidComponents 或 WindowsComponents 并赋值给变量 components。</li>\n</ol>\n<h3>模式</h3>\n<p>\n  整个实现的抽象化表达为：\n  \n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/894be1b40104449d93a184226a213533~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<p>我们称之为抽象工厂模式。你甚至可以将这个模式称为“抽象工厂类模式”，以与“工厂模式”（也即“工厂类模式”）相关联。二者的区别就是“抽象工厂模式”将工厂类也引入了继承体系，用不同子类来返回不同的实例化对象。</p>\n<h2>工厂方法模式(Factory Method)</h2>\n<h3>场景描述</h3>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b956e7f5a3c482e908b83c29841c251~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  现需要实现一个 Game 类进行游戏的渲染和控制，它引用了 GameLogic 用于控制游戏逻辑，如何才能快速的拓展 Game 让我们无需每次生成简单游戏时均需要进行如下操作：\n</p>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-type\">Game</span> <span class=\"hljs-variable\">simpleGame</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Game</span>();\n<span class=\"hljs-type\">SimpleGameLogic</span> <span class=\"hljs-variable\">simpleLogic</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleGameLogic</span>();\nsimpleGame.setLogic(simpleLogic)\n</code></pre>\n<h3>思路</h3>\n<ol>\n  <li>我们可以从 Game 类派生出 SimpleGame、MediumGame、DifficultGame，并重写 Game 中的 getGameLogic()方法，分别返回一个 SimpleGameLogic、MediumGameLogic、DifficultGameLogic 的实例对象。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">start</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">GameLogic</span> <span class=\"hljs-variable\">gameLogic</span> <span class=\"hljs-operator\">=</span> getGameLogic();\n        gameLogic.init();\n        ...\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> GameLogic <span class=\"hljs-title function_\">getGameLogic</span><span class=\"hljs-params\">()</span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleGame</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> GameLogic <span class=\"hljs-title function_\">getGameLogic</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> SimpleGameLogic();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MediumGame</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> GameLogic <span class=\"hljs-title function_\">getGameLogic</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> MediumGameLogic();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DifficultGame</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> GameLogic <span class=\"hljs-title function_\">getGameLogic</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> DifficultGameLogic();\n    }\n}\n</code></pre>\n<ol start=\"2\">\n  <li>当我们需要初始化简单游戏时，仅需：</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-type\">Game</span> <span class=\"hljs-variable\">simpleGame</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleGame</span>();\n</code></pre>\n<ol start=\"3\">\n  <li>这样做的好处是当你需要将简单游戏的逻辑从 SimpleGameLogic 改成 RobotGameLogic 时，不需要修改每个初始化 Game 的地方而仅仅需要修改 SimpleGame 重写的 getGameLogic 方法。</li>\n</ol>\n<h3>模式</h3>\n<p>\n  整个实现的抽象化表达为：\n  \n  <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afc324d243974e6d984d8e2d7c6bfe13~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<p>你可以称之为<strong><em>工厂方法模式</em></strong>，父类定义一个创建对象的方法而让子类决定具体实例化哪个类。</p>\n<p><strong><em>简单工厂模式</em></strong>和<strong><em>抽象工厂模式</em></strong>定义的是一个工厂类，整个类存在的初衷就是用于生产不同的实例，<strong>工厂</strong>二字用于描述整个类。而工厂方法仅仅是业务逻辑中的某个（或某几个）方法是用于在不同派生类中生产不同的实例，<strong>工厂</strong>二字仅仅用于描述类中创建实例相关的部分方法。</p>\n<h3>混淆</h3>\n<p>如有以下类：</p>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> year;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> month;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> day;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">start</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">Date</span> <span class=\"hljs-variable\">date</span> <span class=\"hljs-operator\">=</span> getDate();\n        ...\n    }\n\n    <span class=\"hljs-keyword\">public</span> Date <span class=\"hljs-title function_\">getDate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> year, <span class=\"hljs-type\">int</span> month, <span class=\"hljs-type\">int</span> day)</span> {\n        <span class=\"hljs-type\">Date</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>();\n        result.year = year;\n        result.month = month;\n        result.day = day;\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n}\n</code></pre>\n<p><strong><em>getDate 方法</em></strong>并非<strong><em>工厂方法</em></strong>，而仅能称为<strong><em>构建方法</em></strong>。因为它并未使用继承机制来让派生类决定需要实例化的类。</p>\n<p>实际使用中，我们也可能会把<strong><em>getDate 方法</em></strong>设置成静态方法，有人会称这种模式为<strong><em>静态方法模式</em></strong>，但由于上述原因，它只能被称为<strong><em>静态构建方法</em></strong>。</p>\n<h2>建造者模式(Builder)</h2>\n<h3>场景描述</h3>\n<p>我们有一个宇宙飞船销售网站，有基础款、中级款、高级款可供选择，三者的功能依次变多。同时提供了复古风格、现代风格、像素风格，也即一共有 9 种不同的组合方式。除此之外，我们还需要初始化一串文本用于描述这款车，比如在为飞船添加全景天窗时，在此文本中添加“全景天窗”的描述信息。描述文本有可能被单独获取而无需初始化飞船对象。已知 Spacecraft 类的初始化过程较为复杂（需要初始化框架、发动机等部件），同时我们完全有可能增加更多的款型和风格，新增款型时也需要能够生成对应的描述信息.我们应该如何组织代码以实例化 Spacecraft 对象和 String 类型的描述信息？</p>\n<h3>思路</h3>\n<ol>\n  <li>我们实例化 Spacecraft 时，每为其添加一个属性，需要也在文本描述中添加对应的功能描述，二者的构建过程似乎是完全一样的。</li>\n  <li>我们尝试用一个抽象的 Builder 概念作为它们的接口，来描述整个构建过程的步骤。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">SpacecraftBuilder</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createEngine</span><span class=\"hljs-params\">()</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createCruiseControl</span><span class=\"hljs-params\">()</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createPanoramicRoof</span><span class=\"hljs-params\">()</span>;\n\n    ...\n}\n</code></pre>\n<ol start=\"3\">\n  <li>基础款、中级款的差别在于建造所调用的步骤数量不同，比如初级款就不调用 createPanoramicRoof 方法。所以上述接口的实现类应当是复古风格、现代风格等的构建者和描述构建者。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DescBuilder</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">SpacecraftBuilder</span> {\n    <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">desc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>();\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createEngine</span><span class=\"hljs-params\">()</span> { }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createCruiseControl</span><span class=\"hljs-params\">()</span> {\n        desc.append(<span class=\"hljs-string\">\"定速巡航 \"</span>);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createPanoramicRoof</span><span class=\"hljs-params\">()</span> {\n        desc.append(<span class=\"hljs-string\">\"全景天窗 \"</span>);\n    }\n\n    ...\n\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getDesc</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.desc.toString();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RetroStyleBuilder</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">SpacecraftBuilder</span> {\n    <span class=\"hljs-type\">Spacecraft</span> <span class=\"hljs-variable\">spacecraft</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Spacecraft</span>();\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createEngine</span><span class=\"hljs-params\">()</span> {\n        spacecraft.setEngine(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SteamEngine</span>());\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createCruiseControl</span><span class=\"hljs-params\">()</span> {\n        spacecraft.setCruiseControl(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CruiseControl</span>());\n        spacecraft.setRadar(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Radar</span>());\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createPanoramicRoof</span><span class=\"hljs-params\">()</span> {\n        spacecraft.setPanoramicRoof(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FlowerBenedPanoramicRoof</span>());\n    }\n\n    ...\n\n    <span class=\"hljs-keyword\">public</span> Spacecraft <span class=\"hljs-title function_\">getSpacecraft</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.spacecraft;\n    }\n}\n</code></pre>\n<ol start=\"4\">\n  <li>我们已经具备了所有建造全部款型需要的功能。最后需要做的是为不同的款型和描述文档组装对应的部件。我们新增一个类来管理整个构建流程。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Director</span> {\n    <span class=\"hljs-keyword\">private</span> SpacecraftBuilder builder;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Director</span><span class=\"hljs-params\">(SpacecraftBuilder builder)</span> {\n        <span class=\"hljs-built_in\">this</span>.builder = builder;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">buildBaseModel</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-built_in\">this</span>.builder.createEngine();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">buildIntermediateModel</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-built_in\">this</span>.builder.createEngine();\n        <span class=\"hljs-built_in\">this</span>.builder.createCruiseControl();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">buildAdvancedModel</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-built_in\">this</span>.builder.createEngine();\n        <span class=\"hljs-built_in\">this</span>.builder.createCruiseControl();\n        <span class=\"hljs-built_in\">this</span>.builder.createPanoramicRoof();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">RetroStyleBuilder</span> <span class=\"hljs-variable\">builder</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RetroStyleBuilder</span>();\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Director</span>(builder).buildAdvancedModel();\n    <span class=\"hljs-type\">Spacecraft</span> <span class=\"hljs-variable\">spacecraft</span> <span class=\"hljs-operator\">=</span> builder.getSpacecraft();\n\n    <span class=\"hljs-type\">DescBuilder</span> <span class=\"hljs-variable\">descBuilder</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DescBuilder</span>();\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Director</span>(builder).buildAdvancedModel();\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">desc</span> <span class=\"hljs-operator\">=</span> descBuilder.getDesc(); <span class=\"hljs-comment\">// 定速巡航 全景天窗</span>\n}\n</code></pre>\n<ol start=\"5\">\n  <li>当我们需要新增风格时或者 HTML 格式的描述信息时，新增 Builder 的实现类即可。当我们需要新增车型时，在 Director 中新增 create 方法并调用需要组装的功能即可。</li>\n</ol>\n<h3>模式</h3>\n<p>我们将它称为<strong><em>建造者模式</em></strong>。</p>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd60aafb78784874a55fcd216e3d3666~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<p>其关联于<strong><em>模版模式</em></strong>。</p>\n<h3>问题</h3>\n<ol>\n  <li>我们为什么不将 Director 中的方法直接放入 Builder 这个父类中而要新增一个类来统筹组装过程？</li>\n  <li>与链式调用到底是何关系？</li>\n</ol>\n<h3>混淆</h3>\n<p>如果没有组装<strong>描述文本</strong>的需求，我们完全可以将不同风格纳入抽象工厂模式管理，由子类返回对应风格所使用的引擎、天窗等信息。使用如下：</p>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SpacecraftBuilder</span> {\n    <span class=\"hljs-type\">Spacecraft</span> <span class=\"hljs-variable\">spacecraft</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Spacecraft</span>();\n    <span class=\"hljs-comment\">// 抽象工厂</span>\n    UnitFactory unitFactory;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">RetroStyleBuilder2</span><span class=\"hljs-params\">(UnitFactory unitFactory)</span> {\n        <span class=\"hljs-built_in\">this</span>.unitFactory = unitFactory;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createEngine</span><span class=\"hljs-params\">()</span> {\n        spacecraft.setEngine(unitFactory.getEngine());\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createCruiseControl</span><span class=\"hljs-params\">()</span> {\n        spacecraft.setCruiseControl(unitFactory.getCruiseControl());\n        spacecraft.setRadar(unitFactory.getRadar());\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createPanoramicRoof</span><span class=\"hljs-params\">()</span> {\n        spacecraft.setPanoramicRoof(unitFactory.getPanoramicRoof());\n    }\n\n    <span class=\"hljs-keyword\">public</span> Spacecraft <span class=\"hljs-title function_\">getSpacecraft</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> spacecraft;\n    }\n}\n</code></pre>\n<p>Builder 将不再被纳入继承体系。但这样做的前提是不同风格间的各组件拼凑过程几乎相同，比如如果在为复古风添加全景天窗时，还需要为前挡风玻璃添加花边而其他风格则不用。这样的细微差别在少的情况下倒还能忍受，但一旦数量多了就会使代码陷入混乱，也即需要使用<strong><em>建造者模式</em></strong>。</p>\n<p>抽象工厂模式往往用于直接创建<strong><em>一个继承体系下</em></strong>的某个具体对象并即刻返回，更像是在生产一系列相关对象。而我们以上使用中却在组合对象，即我们在一步步实例化各种组件并添加到飞船中以组装一个复杂对象，并且我们更关心整个对象的拼凑过程。</p>\n<h2>原型模式(Prototype)</h2>\n<h3>场景描述</h3>\n<p>现有一个对象，里面存储了用户传上来的请求体信息，我们将用该对象并行的发送给用户服务和日志服务，但我们不希望用户服务对该对象的更改影响到日志服务对整个原始请求体的保存，也即我们想要复制这个对象。</p>\n<h3>思路</h3>\n<ol>\n  <li>Java 用户，只需要实现 Clonale 接口并实现 clone 方法即可快速完整浅拷贝工作。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CanBeCloneable</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Cloneable</span> {\n    <span class=\"hljs-keyword\">private</span> String username;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">clone</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> CloneNotSupportedException {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">super</span>.clone();\n    }\n}\n</code></pre>\n<ol start=\"2\">\n  <li>如果是深拷贝，我们需要在实现 clone 时，递归调用对象<strong><em>引用数据类型的属性</em></strong>的 clone 方法并赋值给 super.clone()的返回值。</li>\n</ol>\n<h3>模式</h3>\n<p>这就是原型模式，我们为一个类实现克隆接口并提供 clone 方法，以使该类的实例可以被克隆出多个一样的对象。</p>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd176c9ca4524a2ab1868bda6164942b~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h2>单例模式(Singleton)</h2>\n<h3>场景表述</h3>\n<p>现有一个 Property 类，当其实例化时会读取配置文件并为自身的属性赋值。我们不想要每次获取配置时，都实例化该类，因为这会不停的读取配置文件，而这是十分缓慢的。</p>\n<h3>思路</h3>\n<ol>\n  <li>全局维护一个该类的实例，每次获取 Property 类时都返回同一个实例。所以我们的实现如下：</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Property</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Property</span> <span class=\"hljs-variable\">instance</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String applicationName;\n\n    <span class=\"hljs-comment\">// 构造函数为私有的，外部无法直接new Property，以保证单例</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">Property</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-built_in\">this</span>.applicationName = <span class=\"hljs-string\">\"READ FROM CONFIG FILE\"</span>;\n    }\n\n    <span class=\"hljs-keyword\">static</span> Property <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-literal\">null</span>) {\n            instance = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Property</span>();\n        }\n        <span class=\"hljs-keyword\">return</span> instance;\n    }\n}\n</code></pre>\n<ol start=\"2\">\n  <li>在多线程环境中，getInstance 方法需要做同步处理，常规方法是使用<a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F\">双重检查锁</a>机制以兼顾性能与正确性。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Property</span> {\n    <span class=\"hljs-comment\">// 实例化过程中需要阻止重排序，故必须将属性设置为volatile。</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Property</span> <span class=\"hljs-variable\">instance</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String applicationName;\n\n    <span class=\"hljs-comment\">// 构造函数为私有的，外部无法直接new Property，以保证单例</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">Property</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-built_in\">this</span>.applicationName = <span class=\"hljs-string\">\"READ FROM CONFIG FILE\"</span>;\n    }\n\n    <span class=\"hljs-keyword\">static</span> Property <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (instance != <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> instance;\n        <span class=\"hljs-keyword\">synchronized</span> (Property.class) {\n            <span class=\"hljs-keyword\">if</span> (instance != <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> instance;\n            instance = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Property</span>();\n            <span class=\"hljs-keyword\">return</span> instance;\n        }\n    }\n\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getApplicationName</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> applicationName;\n    }\n}\n</code></pre>\n<ol start=\"3\">\n  <li>Java 的静态变量其实自带了延迟加载功能，如下并不会在系统初始化时实例化 ApplicationInfo 而会延迟到调用 Property 的方法时才初始化。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ApplicationInfo</span> {\n    <span class=\"hljs-keyword\">private</span> String name;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">ApplicationInfo</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"ApplicationInfo Constructor\"</span>);\n        <span class=\"hljs-built_in\">this</span>.name = <span class=\"hljs-string\">\"NAME OF APPLICATION\"</span>;\n    }\n\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> name;\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Property</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">ApplicationInfo</span> <span class=\"hljs-variable\">applicationInfo</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ApplicationInfo</span>();\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">hello</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"Hello\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> ApplicationInfo <span class=\"hljs-title function_\">getApplicationInfo</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> applicationInfo;\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        System.out.println(<span class=\"hljs-string\">\"Main\"</span>);\n        Property.hello();\n        Property.getApplicationInfo().getName();\n    }\n}\n<span class=\"hljs-comment\">/**\n * 输出：\n * Main\n * ApplicationInfo Constructor\n * Hello\n */</span>\n</code></pre>\n<h3>模式</h3>\n<p>\n  至此，我们就认识了单例模式。\n  \n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f39fde95c8a4a67bf1f7fe582beb024~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h1>结构型模式(Structural Patterns)</h1>\n<h2>适配器模式(Adapter)</h2>\n<h3>场景描述</h3>\n<p>你有一份老配置文件以及读取这份配置的 OldProperty 类，你还有一份新配置以及读取这份配置的 NewProperty 类。已知新老配置大多是改了配置的字段名以及配置格式，如何才能在系统过度阶段，让 OldProperty 也能像 NewProperty 一样被新系统使用？</p>\n<h3>思路</h3>\n<ol>\n  <li>创建一个中间类，实现 NewProperty 的接口并使用 OldProperty 类提供具体数据。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OldProperty</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">OldPropertyInterface</span> {\n    <span class=\"hljs-keyword\">private</span> String applicationName;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getApplicationName</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> applicationName;\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NewProperty</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">NewPropertyInterface</span> {\n    <span class=\"hljs-keyword\">private</span> ApplicationInfo applicationInfo;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> applicationInfo.getName();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PropertyAdapter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">NewPropertyInterface</span>  {\n    <span class=\"hljs-keyword\">private</span> OldProperty adaptee;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">PropertyAdapter</span><span class=\"hljs-params\">(OldProperty adaptee)</span> {\n        <span class=\"hljs-built_in\">this</span>.adaptee = adaptee;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> adaptee.getApplicationName();\n    }\n}\n\n</code></pre>\n<h3>模式</h3>\n<p>这个中间类及称为适配器，而这种解决方案称为适配器模式。其为两个不兼容的接口提供了兼容的访问方式。</p>\n<p>\n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62a34ab745d54d05936c36f3a8686bc3~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h2>桥接模式(Bridge)</h2>\n<h3>场景描述</h3>\n<p>你有一个 User 类，它可以保存数据到 Mysql 中，也可以保存数据到 PostgreSQL 中。它可以使用阿里云服务发送短信，也可以通过腾讯云服务发送短信。</p>\n<h3>思路</h3>\n<ol>\n  <li>\n    我们不可能创建“MysqlUser”或者“AliUser”甚至于“AliMysqlUser”，似乎更应该参考<strong><em>合成复用原则</em></strong>来组合各个类。\n    \n    <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e62deed8e94741bd84908c5b17eec666~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n</ol>\n<h3>模式</h3>\n<p>\n  此模式强调将一个类或一系列紧密相连的类分为抽象和实现两个部分。抽象部分主要完成业务的抽象操作，比如 save、send 操作，而实现部分则进行具体的实现并提供给抽象部分调用，比如将 save 的数据保存到 MySQL。\n  \n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30357a8bc701479f8debc3db77d8c4a5~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h2>享元模式(Flyweight)</h2>\n<h3>场景描述</h3>\n<p>现有一个活动信息类 Activity，里面除了活动名称、开始时间、结束时间等<strong><em>静态信息</em></strong>外，还包含用户信息等<strong><em>动态信息</em></strong>，因为当调用 getRewards 方法获取活动奖品信息时需要根据个人信息计算具体数值，也就是说每个用户针对每一个活动都需要专门实例化一个活动对象。已知除个人信息外的其他信息占用了该类总存储大小的 99.99%，请问该如何优化内存。</p>\n<h3>思路</h3>\n<ol>\n  <li>静态信息就让它静下来吧，既然它不可变，就用<strong><em>单例模式</em></strong>管理起来，全局就只有一份且不可更改。</li>\n  <li>多个活动间的单例我们需要根据活动名称进行缓存，所以可配合<strong><em>简单工厂模式</em></strong>或<strong><em>静态的工厂方法</em></strong>使用。</li>\n  <li>内部不再维护个人信息字段，该字段在调用 getRewards 时由外部传入，这样此类就仅包含静态信息了。</li>\n  <li>如有需要，可以新建一个类存储个人信息，并引用共享的 Activity 单例对象。</li>\n</ol>\n<h3>模式</h3>\n<p>我们常认为对象包含<strong><em>内部状态</em></strong>和<strong><em>外部状态</em></strong>，二者分别与上述的<strong><em>静态信息</em></strong>和<strong><em>动态信息</em></strong>相对应。</p>\n<p>当内部状态的存储用量远远高于外部状态，或者某一个类需要大量被创建时，可以考虑提取内部状态并为具有相同内部状态的实例提供单例、共享访问的方式。</p>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ca7cc2315994086a650451b51d8948c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<p>这就是享元模式，在 Java 中，基础数据类型的封装类也采用了享元模式进行优化，如常量池的使用。</p>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">\"HI, WHAT'S UP\"</span>);    <span class=\"hljs-comment\">// 手动实例化时将不参与共享</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"HI, WHAT'S UP\"</span>;\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"HI, WHAT'S UP\"</span>;\n        System.out.println(s1 == s2);   <span class=\"hljs-comment\">// false</span>\n        System.out.println(s2 == s3);   <span class=\"hljs-comment\">// true</span>\n        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">i1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Integer</span>(<span class=\"hljs-number\">127</span>);   <span class=\"hljs-comment\">// 手动实例化时将不参与共享</span>\n        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">i2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">127</span>;    <span class=\"hljs-comment\">// 参与共享</span>\n        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">i3</span> <span class=\"hljs-operator\">=</span> Integer.valueOf(<span class=\"hljs-string\">\"127\"</span>);   <span class=\"hljs-comment\">// 参与共享</span>\n        System.out.println(i1 == i2);   <span class=\"hljs-comment\">// false</span>\n        System.out.println(i2 == i3);   <span class=\"hljs-comment\">// true</span>\n        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">i4</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">128</span>;   <span class=\"hljs-comment\">// Integer 仅缓存-128～127范围的数字</span>\n        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">i5</span> <span class=\"hljs-operator\">=</span> Integer.valueOf(<span class=\"hljs-number\">128</span>);\n        System.out.println(i4 == i5);    <span class=\"hljs-comment\">// false</span>\n    }\n}\n</code></pre>\n<h2>外观模式(Facede)</h2>\n<h3>模式</h3>\n<p>为复杂的系统提供一个简单、统一的接口供上层使用，令上层无需与其复杂的系统内部进行交互。</p>\n<p>\n  <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df4cc9d3fa5e4adcb9e528490ccce4c1~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h2>组合模式(Composite)</h2>\n<h3>场景描述</h3>\n<p>现有一种商品礼包，其可能包含一些具体商品和另一个商品礼包。请设计数据结构并提供计算所有具体总价值的方法。</p>\n<h3>思路</h3>\n<ol>\n  <li>\n    首先，商品礼包其实也可以理解为一个商品拥有其价值。所以设计以下继承体系。\n    \n    <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0aa92e0980e4342a245a94ee32c78dc~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n  <li>GoodPack 的 getPrice 方法中将调用 children 中的所有对象的 getPrice 方法并计算求和返回。</li>\n</ol>\n<h3>模式</h3>\n<p>这种将对象组装成树形结构并且可以如同普通对象一样使用组合对象的模式被称为组合模式。</p>\n<p>同时，我们也可以将非叶子结点所特有的属性和方法（如 children 属性，addChild 方法）也加入到父类（或接口）中，但这样树形结构将不再透明，上层也需知晓树形结构的存在。在实际中使用中需根据情况灵活使用。</p>\n<p>\n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d89f54dc12f464687ff1a0d5db92838~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h2>装饰模式(Decorator)</h2>\n<h3>场景描述</h3>\n<p>我们现在拥有一个类 Shop 及其实现的接口，它提供了获取商品于购买商品的功能。但 VIP 用户需要返回一个特别的 Shop，它的商品将更多。需求还不止于此，对于老用户，我们需要增加商品数量并降低价格，对于经常从未付费的用户需要降低商品数量并降低价格。而一个用户完全可能是从未付费的老的 VIP 用户。</p>\n<h3>思路</h3>\n<ol>\n  <li>我们现为从未付费、VIP、老用户三类创建子类，并复写相应方法进行数据的增减。</li>\n  <li>\n    现在我们的问题变成了如何为满足以上两个或者三个条件的用户组装一个 Shop 出来。这时我们可以考虑组合的方式连接多个类。\n    \n    <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/679d10ce84da4dc5aa9c01f4fea62292~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n  <li>Decorator 的派生类则调用 shop 的 getGoodPrice 和 getGoodValue 方法来获取经过层层处理后的结果并进一步进行处理。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Shop</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">ShopInterface</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getGoodValue</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">100</span>;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getGoodPrice</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">100</span>;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">purchase</span><span class=\"hljs-params\">()</span> {\n        System.out.println(String.format(<span class=\"hljs-string\">\"COST: %d\"</span>, <span class=\"hljs-built_in\">this</span>.getGoodPrice()));\n        System.out.printf(String.format(<span class=\"hljs-string\">\"GAIN: %d\"</span>, <span class=\"hljs-built_in\">this</span>.getGoodValue()));\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShopDecorator</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">ShopInterface</span> {\n    <span class=\"hljs-keyword\">protected</span> ShopInterface shop;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">ShopDecorator</span><span class=\"hljs-params\">()</span> {\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">ShopDecorator</span><span class=\"hljs-params\">(ShopInterface shop)</span> {\n        <span class=\"hljs-built_in\">this</span>.shop = shop;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">purchase</span><span class=\"hljs-params\">()</span> {\n        System.out.println(String.format(<span class=\"hljs-string\">\"COST: %d\"</span>, <span class=\"hljs-built_in\">this</span>.getGoodPrice()));\n        System.out.printf(String.format(<span class=\"hljs-string\">\"GAIN: %d\"</span>, <span class=\"hljs-built_in\">this</span>.getGoodValue()));\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">VIPShop</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">ShopDecorator</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">VIPShop</span><span class=\"hljs-params\">(ShopInterface shop)</span> {\n        <span class=\"hljs-built_in\">this</span>.shop = shop;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getGoodPrice</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> shop.getGoodPrice() + <span class=\"hljs-number\">10</span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getGoodValue</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> shop.getGoodValue();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegularVisitorShop</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">ShopDecorator</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">RegularVisitorShop</span><span class=\"hljs-params\">(ShopInterface shop)</span> {\n        <span class=\"hljs-built_in\">this</span>.shop = shop;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getGoodPrice</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> shop.getGoodValue() - <span class=\"hljs-number\">10</span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getGoodValue</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> shop.getGoodValue() + <span class=\"hljs-number\">10</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NeverPayShop</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">ShopDecorator</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">NeverPayShop</span><span class=\"hljs-params\">(ShopInterface shop)</span> {\n        <span class=\"hljs-built_in\">this</span>.shop = shop;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getGoodPrice</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> shop.getGoodValue() - <span class=\"hljs-number\">10</span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getGoodValue</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> shop.getGoodValue() - <span class=\"hljs-number\">1</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">// 组装未付费的老的VIP用户商店</span>\n        <span class=\"hljs-type\">ShopInterface</span> <span class=\"hljs-variable\">shop</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VIPShop</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NeverPayShop</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegularVisitorShop</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Shop</span>())));\n        shop.purchase();\n        <span class=\"hljs-comment\">/**\n         * 输出\n         * COST: 110\n         * GAIN: 109\n         */</span>\n    }\n}\n</code></pre>\n<h3>模式</h3>\n<p>此模式与<strong><em>组合模式</em></strong>有相似之处。</p>\n<p>在结构上，<strong><em>组合模式</em></strong>中，一个包装类包含多个同一继承体系下的子类，为树形结构。而在<strong><em>装饰模式</em></strong>中，一个装饰类仅包含一个同一继承体系下的子类，可以理解为链式结构。</p>\n<p>在业务逻辑上，<strong><em>组合模式</em></strong>中叶子结点完成了大部分的实际工作，包装类只做一些统计与分发，二者是不平等的业务角色。<strong><em>装饰模式</em></strong>中所有结点都在完成各自特有的业务逻辑，属于在增强业务功能，互相是平等的业务角色。</p>\n<p>\n  <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9f5279bcf1746e9a37f2ae5df51533c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h2>代理模式(Proxy)</h2>\n<h3>场景描述</h3>\n<p>我们有一个 MysqlDao 底层类，提供了增删改查方法。我们希望为它添加打印日志的功能，即增删改查时打印操作信息。由于是底层类，你无法直接修改它。</p>\n<h3>思路</h3>\n<ol>\n  <li>既然无法修改，那就把它包起来。新增一个类基础 MysqlDao 实现的所有类和接口，然后将实际的操作委托给内部维护的 MysqlDao 实例，并在转发前后打上日志即可。</li>\n</ol>\n<h3>模式</h3>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49b1af01c86941dba5dc47e7be2b1bf5~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<p>我们称这个新增的类为代理类，称这种解决方案为代理模式。</p>\n<p>它和<strong><em>装饰器模式</em></strong>很像，都是基于组合原则，包装一个类然后进行转发并添加一些额外的操作，</p>\n<p>但二者的意图不同。装饰器的层层装饰是客户端可随意组合的，用于功能增强。但代理模式往往希望外部直接使用代理类，其增加的功能一般与业务无关。</p>\n<p>它也不同于<strong><em>外观模式</em></strong>，外观模式需要暴露更少的接口以隐藏复杂的内部结构，而代理类与其代理对象遵循同一接口。</p>\n<h1>行为模式(Behavioral Design Patterns)</h1>\n<h2>责任链模式(Chain of Responsibility)</h2>\n<h3>场景描述</h3>\n<p>你又有一个 MysqlDao 底层类，提供了查数据的方法。现在你需要为它提供可选的两级缓存功能，即本地缓存、Redis 缓存，任意缓存被命中时直接返回数据。按照惯例，因为它是底层类，你无法直接修改它。</p>\n<h3>思路</h3>\n<ol>\n  <li>好像<strong><em>代理模式</em></strong>也能用，但我们并不期待客户端都使用缓存功能，并且这似乎也已经涉及到具体业务修改，再者如果以后需要提供三级四级缓存则需要不断的修改代理类，这对开闭原则并不友好。</li>\n  <li>\n    <strong><em>装饰器模式</em></strong>是个很好的选择，一级二级缓存层层包装，且可以选择性的使用本地缓存、Redis 缓存或两者都使用。\n    \n    <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d526ef3895bb405684bbf4671778bc2f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n  <li>CacheDao 的 next 均指向下一个处理的 DAO，如果当前未发现缓存，则将请求转发给 next 类，直到最后到达 MysqlDao。但如果发现了缓存，则不再转发直接返回。</li>\n</ol>\n<h3>模式</h3>\n<p>注意，这里我们多了一个阻断操作，也即某一个中间类发现我能处理，则不再向下传递。这一点不是<strong><em>装饰器模式</em></strong>的初衷，装饰器模式是用于拓展、增强行为，但核心功能还是由原始类完成或参与。</p>\n<p>\n  <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e56e6622a4d748b09a9e580d81aded9d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  这种模式称为职责链模式，若我们需要为 HTTP 请求添加“IP 限制”、“请求频率限制”、“登录校验”等功能时就可以使用此模式。\n</p>\n<h2>备忘录模式(Memento)</h2>\n<h3>场景描述</h3>\n<p>现在有象棋游戏逻辑类 ChessGame 和 UI 渲染层的 ChessFrame 类，你需要记录每次操作并提供无限次数的悔棋功能。</p>\n<h3>思路</h3>\n<ol>\n  <li>我们在每次操作时，需要记录当时的棋子布局等游戏信息。而此操作应由 ChessGame 进行，因为只有它知晓有哪些内部信息需要被存储。</li>\n  <li>产生的游戏信息我们新增一个类 Snapshot 来存储。而我们希望这些快照信息的维护交由一个专门的 Caretaker 类维护以使 ChessGame 仅需提供创建快照和根据快照恢复游戏两个功能即可。</li>\n  <li>当悔棋时，ChessFrame 触发 Caretaker 的恢复功能，调用 ChessGame 的 restore 方法并传入最近的一次快照，使恢复上一次操作前的状态。</li>\n</ol>\n<h3>模式</h3>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfd83a9f5a40406eaa30c6cd32043098~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h2>命令模式(Command)</h2>\n<h3>场景描述</h3>\n<p>现在你是一个游戏开发者，界面上有很多建筑 Building 对象并提供了一些诸如设置外观、设置描述文本、设置倒计时等基本功能可供调用。我们希望提供多种功能（比如升级建筑、查看建筑等），调用不同功能时，会给 Building 设置不同的外观、描述、倒计时等，而不同的事件可能会调用相同或不同的功能。</p>\n<h3>思路</h3>\n<ol>\n  <li>我们完全可以在 Building 中添加 upgrade、view 等方法以提供这些功能。但我们发现这些功能都是对于基本功能的集成且很容易变更相关需求，所以考虑使用另一个类来调用 Building 的基本功能。</li>\n  <li>\n    我们把每一个功能都用一个单独的类来表示，以在添加或删除功能时，只需要新增或删除这些功能类即可。\n    \n    <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/411bad51c8354ec59fc391e78a91b2eb~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n</ol>\n<h3>模式</h3>\n<p>\n  <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e360418021fd4fcd9589f96a3071597c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  如果你希望在一众零散基础功能基础上组装多样化的操作命令则可以使用<strong><em>命令模式</em></strong>。有撤销操作需求，我们也可以在 Command 中添加 revert 方法，以保证 do 与 revert 的逻辑被放在一起。也可以与<strong><em>备忘录</em></strong>模式配合使用实现历史命令的缓存。\n</p>\n<h2>状态模式(State)</h2>\n<h3>场景描述</h3>\n<p>现在你是一个游戏开发者，界面上有很多建筑 Building 对象处于不同的状态（正常、修建中、拆除中等 n 种）。而建筑有建造、拆除、查看等功能可供调用。问题在于当建筑处于不同的状态时，可执行的操作不尽相同。比如修建中的建筑将不能执行建造、升级等操作。你会如何设计 Building 类使其满足以上需求？</p>\n<h3>思路</h3>\n<ol>\n  <li>第一反应可能会是在 Building 的建造、拆除、升级方法中添加状态的判断。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Building</span> {\n    <span class=\"hljs-keyword\">private</span> String state;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">build</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (!state.equals(<span class=\"hljs-string\">\"NORMAL\"</span>)) <span class=\"hljs-keyword\">return</span>;\n        state = <span class=\"hljs-string\">\"BUILDING\"</span>;\n        System.out.println(<span class=\"hljs-string\">\"To state: building\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (!state.equals(<span class=\"hljs-string\">\"NORMAL\"</span>) &#x26;&#x26; !state.equals(<span class=\"hljs-string\">\"BUILDING\"</span>)) <span class=\"hljs-keyword\">return</span>;\n        state = <span class=\"hljs-string\">\"REMOVING\"</span>;\n        System.out.println(<span class=\"hljs-string\">\"To state: removing\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">display</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"Building Name: Tower\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">info</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (state.equals(<span class=\"hljs-string\">\"NORMAL\"</span>)) {\n            System.out.println(<span class=\"hljs-string\">\"Building Name: Tower\"</span>);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (state.equals(<span class=\"hljs-string\">\"REMOVING\"</span>)) {\n            System.out.println(<span class=\"hljs-string\">\"Removing For: 11s\"</span>);\n        }\n    }\n}\n</code></pre>\n<ol start=\"2\">\n  <li>这看起来不太整洁，整理逻辑也会很麻烦。我们可以尝试把 state 做成类 State 并把与状态相关的建筑操作转发给 State，然后派生出不同的建筑状态，而该状态能执行的操作则反过来调用 Building 的方法进行实现，如此一来，建筑处于什么状态时可以执行哪些操作便一目了然。</li>\n  <li>\n    同时，不要忘了在执行了某些操作之后实例化新的状态类并赋值给 Building 的 state 属性。\n    \n    <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e6f84a873ed4dce93c1b522e133159c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Building</span> {\n    <span class=\"hljs-keyword\">protected</span> State state;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">build</span><span class=\"hljs-params\">()</span> {\n        state.build();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">()</span> {\n        state.remove();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">display</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"Building Name: Tower\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">info</span><span class=\"hljs-params\">()</span> {\n        state.info();\n    }\n\n    <span class=\"hljs-comment\">// 真正的建造逻辑</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doBuild</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"build now\"</span>);\n    }\n\n     <span class=\"hljs-comment\">// 真正的拆除逻辑</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doRemove</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"remove now\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">State</span> {\n    <span class=\"hljs-keyword\">protected</span> Building building;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">State</span><span class=\"hljs-params\">(Building building)</span> {\n        <span class=\"hljs-built_in\">this</span>.building = building;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">build</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"do nothing\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"do nothing\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">info</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"do nothing\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NormalState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">State</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">NormalState</span><span class=\"hljs-params\">(Building building)</span> {\n        <span class=\"hljs-built_in\">super</span>(building);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">build</span><span class=\"hljs-params\">()</span> {\n        building.doBuild();\n        System.out.println(<span class=\"hljs-string\">\"To state: building\"</span>);\n        building.state = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BuildingState</span>(building);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">()</span> {\n        building.doRemove();\n        System.out.println(<span class=\"hljs-string\">\"To state: removing\"</span>);\n        building.state = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RemovingState</span>(building);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">info</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"Building Name: Tower\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BuildingState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">State</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">BuildingState</span><span class=\"hljs-params\">(Building building)</span> {\n        <span class=\"hljs-built_in\">super</span>(building);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">()</span> {\n        building.doRemove();\n        System.out.println(<span class=\"hljs-string\">\"To state: removing\"</span>);\n        building.state = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RemovingState</span>(building);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RemovingState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">State</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">RemovingState</span><span class=\"hljs-params\">(Building building)</span> {\n        <span class=\"hljs-built_in\">super</span>(building);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">info</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">\"Removing For: 11s\"</span>);\n    }\n}\n</code></pre>\n<h3>模式</h3>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea62eb8248d94ea5ad584f71e62caf86~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  在有限的状态中，我们可以使用此模式进行循环的转换并在不同的状态执行不同的操作，称为状态模式。\n</p>\n<h2>访问者模式(Visitor)</h2>\n<h3>场景描述</h3>\n<p>你现在是一个游戏开发者，界面上有很多建筑处于不同的状态（正常、修建中、拆除中等 n 种）。我们有多种操作可能被触发（鼠标左键点击、鼠标右键点击、手指点击、手指双击等 m 种），对不同状态的建筑进行不同的操作会调用对应状态类的不同方法。如何统筹这复杂的 n*m 种调用关系？</p>\n<h3>思路</h3>\n<ol>\n  <li>首先我们会用<strong><em>状态模式</em></strong>来管理所有状态，也即所有的建筑状态均继承自一个父类 State，建筑类中有一个 State 类型的属性表示该建筑的状态。</li>\n  <li>这似乎可以在不同的状态类中分别添加 m 种函数对应不同的操作。但这有一些小问题，每当我们需要添加或删除一种操作时，都需要修改 n 个状态类。同时，事件的触发和房屋的<strong>功能逻辑</strong>在一定程度上是耦合的。</li>\n  <li>那就建立 m 个事件类吧，并提供 n 个同名函数利用多态对应不同的建筑状态下触发此事件。</li>\n  <li>对于 C#、Groovy 等支持<a href=\"&#x27;https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%88%86%E6%B4%BE&#x27;\">多分派</a>的语言，我们已经实现了<strong><em>访问者模式</em></strong>。</li>\n  <li>对于 C、Java 等语言，还有一个问题可能需要到实际开发时才会发现。当我们向一个建筑触发一个状态相关的事件时，我们只能拿到一个 State 类型的值，而不是具体的状态子类。那我们在第二步中的通过建筑状态调用不同的函数如何实现呢？</li>\n  <li>好像需要这样：</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Event</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFor</span><span class=\"hljs-params\">(State state)</span> {\n        <span class=\"hljs-keyword\">if</span> (state <span class=\"hljs-keyword\">instanceof</span> NormalState) {\n            doFor((NormalState) state);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (state <span class=\"hljs-keyword\">instanceof</span> BuildingState) {\n            doFor((BuildingState) state);\n        }\n        ...\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFor</span><span class=\"hljs-params\">(NormalState state)</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFor</span><span class=\"hljs-params\">(BuildingState state)</span>;\n\n    ...\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClickEvent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Event</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFor</span><span class=\"hljs-params\">(NormalState state)</span> {\n        state.build();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFor</span><span class=\"hljs-params\">(BuildingState state)</span> {\n        state.info();\n    }\n\n    ...\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">main</span>() {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">State</span> <span class=\"hljs-variable\">state</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NormalState</span>();\n        state.accept(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ClickEvent</span>());\n    }\n}\n</code></pre>\n<ol start=\"7\">\n  <li>既然父类帮我们统一做了处理，那问题也不大，但无法否认这是典型的坏味道。</li>\n  <li>我们可以通过模拟<a href=\"&#x27;https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%88%86%E6%B4%BE&#x27;\">多分派</a>来优化。</li>\n  <li>我们在 State 类中添加一个新方法 accept 用来接收 Event 并代为执行 Event::doFor 方法，当我们调用 accept 时，this 引用将指向具体的状态子类，我们运行 Event.doFor(this)即可实现传入具体状态子类的目标。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Event</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFor</span><span class=\"hljs-params\">(NormalState state)</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFor</span><span class=\"hljs-params\">(BuildingState state)</span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClickEvent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Event</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFor</span><span class=\"hljs-params\">(NormalState state)</span> {\n        state.build();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFor</span><span class=\"hljs-params\">(BuildingState state)</span> {\n        state.info();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NormalState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">State</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">accept</span><span class=\"hljs-params\">(Event event)</span> {\n        event.doFor(<span class=\"hljs-built_in\">this</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BuildingState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">State</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">accept</span><span class=\"hljs-params\">(Event event)</span> {\n        event.doFor(<span class=\"hljs-built_in\">this</span>);\n    }\n}\n\n<span class=\"hljs-comment\">// 状态模式中，对state的调用往往需要通过Building类转发</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Buillding</span> {\n    <span class=\"hljs-keyword\">private</span> State state;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">accept</span><span class=\"hljs-params\">(Event event)</span> {\n        state.accept(evevt);\n    }\n}\n</code></pre>\n<ol start=\"10\">\n  <li>通过这样的转发，我们新增或删除 Event 时，只需添加或删除对用的 Event 派生类，而无需续写或删除<strong><em>instanceof</em></strong>的条件判断，因为 State 和 Building 知晓了 Event 的存在，在一定程度上这违背<strong><em>迪米特法则</em></strong>，却更符合<strong><em>开闭原则</em></strong>。</li>\n</ol>\n<h3>模式</h3>\n<p>这就是访问者模式，Event 为访问者，其访问 State 的方法或变量。事件与业务操作的对应关系由访问者维护，减少了被访者的复杂性。</p>\n<p>\n  <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54208f471d0c4f67a3a6e6c7626755cf~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h3>新需求</h3>\n<p>如果我们在此场景之下增加”撤回功能“的需求，你会如何实现？</p>\n<h2>迭代器模式(Iterator)</h2>\n<h3>场景描述</h3>\n<p>你现在是一个数据挖掘工程师，你维护着数以亿计从微博、微信等挖掘而来的公共账户信息。有多个业务方希望我们提供所有的头像数据供他们使用，如需要所有男性的头像、需要所有女性头像等。你需要提供函数返回对应头像数据给业务方。注意，你仅存储了头像的地址，图片数据需要从网络上进行下载。</p>\n<h3>思路</h3>\n<ol>\n  <li>由于数据量巨大（数以亿计的需要下载的图片资源），我们无法简单的返回一个 List。</li>\n  <li>\n    我们采用一个一个头像返回的方式，供业务方调用，也即我们自行实现迭代器。\n    \n    <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac53670329fb4be599db8977eec1a394~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">byte</span>[] next() {\n    <span class=\"hljs-comment\">/**\n     * select account info by invoking methods provided by socialMediae\n     * according this.lastId and this.gender\n     */</span>\n    <span class=\"hljs-type\">AccountInfo</span> <span class=\"hljs-variable\">nextAccount</span> <span class=\"hljs-operator\">=</span> ... INVOKE ...\n    <span class=\"hljs-type\">byte</span>[] avatar = ... DOWNLOAD avatar ...\n    <span class=\"hljs-built_in\">this</span>.lastId = nextAccount.id;\n    <span class=\"hljs-keyword\">return</span> avatar;\n}\n</code></pre>\n<ol start=\"3\">\n  <li>新增的访问逻辑和迭代进度（lastId）在 Iterator 中维护，我们没有因为此次需求而在 AccountManager 中添加具体的业务操作（仅添加了迭代器入口），这符合开闭原则。</li>\n</ol>\n<h3>模式</h3>\n<p>\n  这便是<strong><em>迭代器模式</em></strong>。\n  \n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f18873e311b04f13ba4e5ef8e86bdc0f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  使用此模式的常用场景包括：\n</p>\n<ol>\n  <li>单条数据获取极为耗时，无法一次性全部获取。即：头像数据可以依次下载，无需耗费大量的时间和空间先行下载全部数据后再返回给调用者。</li>\n  <li>内部的存储结构比较复杂（如树形、链式结构混合使用等），希望对外界以统一的方式进行遍历。即：我们屏蔽掉了存储的差异性，我们隐藏了数据存储于不同表（甚至于不同 DB）的事实。</li>\n</ol>\n<h2>观察者模式(Observer)</h2>\n<h3>场景</h3>\n<p>当用户登录时，需要统计昨日简报、推送天气状况、刷新每日奖励等。当 VIP 即将过期时，需要发送具体过期时间的推送通知、赠送购买优惠券等。如果这样的事件与对应的操作诸多、杂乱、不稳定，请问你会如何设计代码？</p>\n<h3>思路</h3>\n<ol>\n  <li>开发前期，事件与操作相对简单明了时，往往可以直接在登录的函数中直接调用统计、推送、刷新等相关函数。但随着二者的对应关系日趋复杂，我们需要更为灵活的设计。</li>\n  <li>\n    我们可以使用<strong><em>订阅/发布机制</em></strong>，业务自行向自己感兴趣的事件进行订阅，当事件发生时，事件类将调用所有订阅了此事件的方法。\n    \n    <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a318056c3c134bdcb4c281d012dbbae7~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractEvent</span> {\n    <span class=\"hljs-keyword\">private</span> Set&#x3C;Listener> listeners = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&#x3C;>();\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">subscribe</span><span class=\"hljs-params\">(Listener listener)</span> {\n        listeners.add(listener);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">unsubscribe</span><span class=\"hljs-params\">(Listener listener)</span> {\n        listeners.remove(listener);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">on</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">for</span> (Listener listener : listeners) {\n            listener.onEvent(<span class=\"hljs-built_in\">this</span>);\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoginEvent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractEvent</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">long</span> userId;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">getUserId</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> userId;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setUserId</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> userId)</span> {\n        <span class=\"hljs-built_in\">this</span>.userId = userId;\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Listener</span>&#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractEvent</span>> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onEvent</span><span class=\"hljs-params\">(T event)</span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DailyRewardsListener</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Listener</span>&#x3C;LoginEvent> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onEvent</span><span class=\"hljs-params\">(LoginEvent event)</span> {\n        System.out.println(String.format(<span class=\"hljs-string\">\"user %d login success\"</span>, event.getUserId()));\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">LoginEvent</span> <span class=\"hljs-variable\">event</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LoginEvent</span>();\n    <span class=\"hljs-type\">DailyRewardsListener</span> <span class=\"hljs-variable\">listener</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DailyRewardsListener</span>();\n    event.subscribe(listener);\n    event.setUserId(<span class=\"hljs-number\">1000</span>);\n    event.on(); <span class=\"hljs-comment\">// user 1000 login success</span>\n    event.unsubscribe(listener);\n    event.on(); <span class=\"hljs-comment\">// NO OUTPUT</span>\n}\n</code></pre>\n<h3>模式</h3>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60474ec6580c46408d502852ed05cab0~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h3>变体</h3>\n<p>在具体实践中，可以使用一个中间类来维护监听关系、广播事件，而不在父类 Event 中进行，如 Spring 中的<strong>ApplicationEventMulticaster</strong>类。因为我们仅仅实例化了一次具体事件类以接受监听器注册，当并发条件下多个用户触发登录事件时，会存在并发问题。</p>\n<p>上述场景中加入<strong>EventManager</strong>作为中间类时实现如下：</p>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75987e83bf574b148fe2be70d114c497~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EventManager</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&#x3C;Class&#x3C;? <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Event</span>>, Set&#x3C;Listener>> listeners = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>();\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Event</span>> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">subscribe</span><span class=\"hljs-params\">(Class&#x3C;T> event, Listener&#x3C;T> listener)</span> {\n        Set&#x3C;Listener> set = listeners.getOrDefault(event, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>());\n        set.add(listener);\n        listeners.put(event, set);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Event</span>> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">unsubscribe</span><span class=\"hljs-params\">(Class&#x3C;T> event, Listener&#x3C;T> listener)</span> {\n        Set&#x3C;Listener> set = listeners.getOrDefault(event, Collections.emptySet());\n        set.remove(listener);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Event</span>> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">on</span><span class=\"hljs-params\">(T event)</span> {\n        <span class=\"hljs-keyword\">for</span> (Listener listener: listeners.getOrDefault(event.getClass(), Collections.emptySet())) {\n            listener.onEvent(event);\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    EventManager.subscribe(LoginEvent.class, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DailyRewardsListener</span>());\n    EventManager.on(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LoginEvent</span>(<span class=\"hljs-number\">1000</span>)); <span class=\"hljs-comment\">// user 1000 login success</span>\n    EventManager.on(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LoginEvent</span>(<span class=\"hljs-number\">2000</span>)); <span class=\"hljs-comment\">// user 2000 login success</span>\n}\n</code></pre>\n<p>有人将这种添加了中间类的<strong><em>观察者模式</em></strong>称为<strong><em>订阅/发布模式</em></strong>，这种做法有待商榷。</p>\n<h2>中介者模式(Mediator)</h2>\n<h3>场景描述</h3>\n<p>我们现在有 Mysql、Redis、Elasticsearch 等多种数据库，我们有一些数据备份的需求。如当存储数据到 Mysql 时，需要同时存储到 Redis、Elasticsearch 等多达十几种 DB，当存储数据到 Elasticsearch 时，需要同时存储到 Mysql 等几种 DB。</p>\n<h3>思路</h3>\n<ol>\n  <li>我们可以在保存数据到 Mysql、Redis、Elasticsearch 的函数中，同时操作另外其他 DB 以进行同步。</li>\n  <li>但 DB 数种类众多，如 Mysql 工具种将引用多达十几种 DB。同时，各 DB 间的备份流程分布在不同的 DB 工具中，难以维护。</li>\n  <li>\n    考虑使用一个上帝类，管理所有 DB，用某种 DB 存储数据时，告知上帝类，由上帝类来决定需要同时将数据备份到哪些数据库。这样即可解决以上两个问题。\n    \n    <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd221444bc574a58a1e36cbaa2674716~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n</ol>\n<h3>模式</h3>\n<p><strong><em>中介者模式</em></strong>主要为了解决类之间多对多的调用关系，使原本需要与所有相关类交互转变成只需与中介者交互，使出了中间类外的其他类更符合<strong><em>迪米特法则</em></strong>和<strong><em>单一职责原则</em></strong>。但它的缺点也很明显，中介者需要知晓整个功能所涉及到的所有类，极可能成为<a href=\"https://zh.wikipedia.org/zh-hans/%E4%B8%8A%E5%B8%9D%E5%AF%B9%E8%B1%A1\">上帝对象</a>。</p>\n<h2>策略模式(Strategy)</h2>\n<h3>场景描述</h3>\n<p>我们需要对一段数据进行加密/解密，而有 DES、AES 等多种加密方式可供选择。而加密方式存储于用户表中由用户自行决定。当用户请求一个接口时会告知加密方式，你需要解密用户上传的数据并添加部分文字后再加密返回给用户。请问你会如何实现？</p>\n<h3>思路</h3>\n<ol>\n  <li>我们理应提供 DESTools、AESTools 提供加密/解密方法。</li>\n  <li>根据传入的加密方式使用不同的 Tools。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">handle</span><span class=\"hljs-params\">(String ciphertext, EncryptAlgorithm algorithm)</span> {\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">text</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">switch</span> (algorithm) {\n        <span class=\"hljs-keyword\">case</span> DES:\n            text = DESEncryptor.decrypt(ciphertext);\n            <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> AES:\n            text = AESEncryptor.decrypt(ciphertext);\n            <span class=\"hljs-keyword\">break</span>;\n    }\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> text + <span class=\"hljs-string\">\" by Server\"</span>;\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">resultCiphertext</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">switch</span> (algorithm) {\n        <span class=\"hljs-keyword\">case</span> DES:\n            resultCiphertext = DESEncryptor.encrypt(result);\n            <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> AES:\n            resultCiphertext = AESEncryptor.encrypt(result);\n            <span class=\"hljs-keyword\">break</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> resultCiphertext;\n}\n</code></pre>\n<ol start=\"3\">\n  <li>这似乎难以接受，更恰当的做法是新增公共接口 EncryptTools。</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">handle</span><span class=\"hljs-params\">(String ciphertext, EncryptAlgorithm algorithm)</span> {\n    <span class=\"hljs-type\">Encryptor</span> <span class=\"hljs-variable\">encryptor</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">switch</span> (algorithm) {\n        <span class=\"hljs-keyword\">case</span> DES:\n            encryptor = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DESEncryptor</span>();\n            <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> AES:\n            encryptor = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AESEncryptor</span>();\n            <span class=\"hljs-keyword\">break</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> encryptor.encrypt(encryptor.decrypt(ciphertext) + <span class=\"hljs-string\">\" by Server\"</span>);\n}\n</code></pre>\n<h3>模式</h3>\n<p>我们不知不觉中又用到了一种设计模式，即做<strong><em>策略模式</em></strong>。不同的加密算法即为不同的策略。</p>\n<p>\n  <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c702c636dcc44e3b228e6b5dafafb33~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h3>延伸</h3>\n<p>在支持枚举类的语言中，我们往往可以借助枚举来使用<strong>策略模式</strong>，使代码更整洁、简单。</p>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">EncryptAlgorithm</span> {\n    DES {\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> Encryptor <span class=\"hljs-title function_\">getEncryptor</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DESEncryptor</span>();\n        }\n    },\n    AES {\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> Encryptor <span class=\"hljs-title function_\">getEncryptor</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AESEncryptor</span>();\n        }\n    };\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> Encryptor <span class=\"hljs-title function_\">getEncryptor</span><span class=\"hljs-params\">()</span>;\n}\n\n<span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">handle</span><span class=\"hljs-params\">(String ciphertext, EncryptAlgorithm algorithm)</span> {\n    <span class=\"hljs-type\">Encryptor</span> <span class=\"hljs-variable\">encryptor</span> <span class=\"hljs-operator\">=</span> algorithm.getEncryptor();\n    <span class=\"hljs-keyword\">return</span> encryptor.encrypt(encryptor.decrypt(ciphertext) + <span class=\"hljs-string\">\" by Server\"</span>);\n}\n</code></pre>\n<p>其中<strong><em>getEncryptor</em></strong>方法是一个工厂方法。</p>\n<h2>模版方法(Template Method)</h2>\n<h3>场景描述</h3>\n<p>我们有 DESTools、AESTools 等多个加密工具对应到不同的加密算法。加密/解密均包含多个步骤，如加密步骤包括压缩数据、生成密钥、加密、字节充填等。请问我们应该如何规划这些 Tools 类的 encrypt、decrypt 方法？</p>\n<h3>思路</h3>\n<ol>\n  <li>我们可以尝试直接在 encrypt 方法中按顺序书写所有的加密步骤。</li>\n  <li>但我们发现，无论何种加密算法，其步骤及顺序均是相同的，直至具体实现不同，甚至压缩数据等操作的具体实现也是一样的。</li>\n  <li>\n    我们尝试在公共父类 Encryptor 中，为各步骤分别添加一个抽象方法供子类实现，同时添加一个<strong><em>模版方法</em></strong>并顺序的调用这些抽象方法。对于所有算法实现上均相同的部分步骤，我们可以不作为抽象方法而提供公共的实现。\n    \n    <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6624cff0bed04758a65cb88018b649d1~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n  </li>\n</ol>\n<h3>模式</h3>\n<p>encrypt、decrypt 方法即成为<strong><em>模版方法</em></strong>。我们称这种将公共流程放入<strong><em>模版方法</em></strong>，具体每个步骤在派生类中实现的模式称为<strong><em>模版方法模式</em></strong>。</p>\n<p>\n  <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6203542a5cf4610ba835161754d0a7e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h2>解释器模式(Interpreter)</h2>\n<p>\n  <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f982ca4d685472bb5e0f4e8e5faacde~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">\n</p>\n<h1>总结</h1>\n<p>\n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba292f5bd39c4f2d999190bb6feae886~tplv-k3u1fbpfcp-watermark.image?\" alt=\"5-201123151944949.png\">\n</p>\n"},"className":"post_post_content__Tzmbb markdown_post_content__WBo_I"}]]
